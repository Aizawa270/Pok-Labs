// index.js
const fs = require('fs');
const path = require('path');
const { Client, GatewayIntentBits, Partials, Collection } = require('discord.js');
const { init: initDb, ensureUserExists } = require('./src/lib/db');

const PREFIX = process.env.BOT_PREFIX || '%';
const ADMIN_IDS = (process.env.ADMIN_IDS || '').split(',').map(s => s.trim()).filter(Boolean);

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.DirectMessages
  ],
  partials: [Partials.Channel]
});

// init DB
const db = initDb();
client.db = db;

// load small static data
function readData(name) {
  try { return JSON.parse(fs.readFileSync(path.join(__dirname, 'data', name), 'utf8')); }
  catch (e) { return null; }
}
client.regionsStatic = readData('regions.json') || [];
client.gymsStatic = readData('gyms.json') || [];
client.pokedex = readData('pokedex.json') || {}; // file generated by builder in Actions if not present locally

// load commands
client.commands = new Collection();
function loadCommands() {
  const cmdsDir = path.join(__dirname, 'src', 'commands');
  if (!fs.existsSync(cmdsDir)) return;
  (function walk(dir) {
    for (const it of fs.readdirSync(dir, { withFileTypes: true })) {
      const full = path.join(dir, it.name);
      if (it.isDirectory()) { walk(full); continue; }
      if (!it.name.endsWith('.js')) continue;
      delete require.cache[require.resolve(full)];
      const cmd = require(full);
      if (!cmd || !cmd.name) continue;
      client.commands.set(cmd.name, cmd);
      console.log('Loaded command', cmd.name);
    }
  })(cmdsDir);
}
loadCommands();

client.once('ready', () => {
  console.log(`Logged in as ${client.user.tag}`);
});

client.on('messageCreate', async (message) => {
  if (message.author.bot) return;
  const userId = message.author.id;
  ensureUserExists(client.db, userId);

  const isAdmin = ADMIN_IDS.includes(userId);
  const content = message.content.trim();
  if (!content) return;

  // prefix commands
  if (content.startsWith(PREFIX)) {
    const without = content.slice(PREFIX.length).trim();
    const [cmdName, ...args] = without.split(/\s+/);
    return handleCommand(message, cmdName.toLowerCase(), args, isAdmin);
  }

  // prefixless commands (users listed in data/prefixless.json)
  let prefixlessList = [];
  try { prefixlessList = JSON.parse(fs.readFileSync(path.join(__dirname, 'data', 'prefixless.json'), 'utf8')); } catch {}
  if (prefixlessList.includes(userId)) {
    const [cmdName, ...args] = content.split(/\s+/);
    return handleCommand(message, cmdName.toLowerCase(), args, isAdmin);
  }
});

async function handleCommand(message, cmdName, args, isAdmin) {
  const cmd = client.commands.get(cmdName);
  if (!cmd) return;
  try {
    await cmd.execute({ client, message, args, isAdmin });
  } catch (err) {
    console.error('Command error', err);
    try { await message.reply('An error occurred while running that command.'); } catch {}
  }
}

const token = process.env.DISCORD_TOKEN;
if (!token) {
  console.error('Missing DISCORD_TOKEN in environment (GitHub Secret).');
  process.exit(1);
}
client.login(token);